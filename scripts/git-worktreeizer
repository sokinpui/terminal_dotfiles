#!/bin/sh
#
# Git Worktree Manager (Extendable Dispatcher Model)

# --- Handler: Switch Interactively ---
_wt_switch() {
  if ! command -v fzf >/dev/null 2>&1; then
    printf "Error: 'fzf' is required for interactive switching.\n" >&2
    exit 1
  fi
  worktree_list=$(git -C "$GIT_ROOT" worktree list)
  if [ -z "$worktree_list" ]; then
    printf "No git worktrees found to switch to.\n" >&2
    exit 1
  fi
  selected_path=$(printf "%s" "$worktree_list" | fzf --height 40% --reverse | awk '{print $1}')
  [ -n "$selected_path" ] && printf "%s" "$selected_path" || exit 1
}

# --- Handler: Switch to Last Worktree ---
_wt_switch_last() {
  LAST_WT_FILE="${HOME}/.wt_last"
  if [ -r "$LAST_WT_FILE" ]; then
    cat "$LAST_WT_FILE"
  else
    printf "Error: No last worktree recorded.\n" >&2
    exit 1
  fi
}

# --- Handler: Add a New Worktree ---
_wt_add() {
  branch_name="$1"
  if [ -z "$branch_name" ]; then
    printf "Error: 'add' command requires a branch name.\nUsage: wt add <branch>\n" >&2
    exit 1
  fi
  if ! git check-ref-format --branch "$branch_name" >/dev/null 2>&1; then
    printf "Error: Invalid branch name: '%s'.\n" "$branch_name" >&2
    exit 1
  fi

  worktree_path="$GIT_ROOT.wt/$branch_name"

  if [ -d "$worktree_path" ]; then
    printf "Worktree for branch '%s' already exists. Switching.\n" "$branch_name" >&2
    printf "%s" "$worktree_path"
    return
  fi

  mkdir -p "$(dirname "$worktree_path")"
  printf "Creating worktree for branch '%s'...\n" "$branch_name" >&2
  if git rev-parse --verify --quiet "$branch_name" >/dev/null 2>&1; then
    git worktree add "$worktree_path" "$branch_name" >&2
  else
    git worktree add -b "$branch_name" "$worktree_path" >&2
  fi

  if [ $? -ne 0 ]; then
    printf "Error: 'git worktree add' failed.\n" >&2
    exit 1
  fi
  printf "%s" "$worktree_path"
}

# --- Handler: Remove a Worktree (Example of extendability) ---
_wt_remove() {
  printf "Error: 'remove' command not yet implemented.\n" >&2
  exit 1
}

# --- Handler: List Worktrees (Example of extendability) ---
_wt_list() {
  git -C "$GIT_ROOT" worktree list
  # This command doesn't output a path, so we exit 2 to prevent 'cd'.
  exit 2
}

# --- Main Dispatcher ---
# Pre-flight check for git repository
GIT_ROOT=$(git worktree list --porcelain | grep "^worktree " | awk '{print $2}' | head -1)
if [ -z "$GIT_ROOT" ]; then
  printf "Error: Not a git repository.\n" >&2
  exit 1
fi

subcommand="$1"
shift_count=1

case "$subcommand" in
"" | "switch")
  _wt_switch
  ;;
"-")
  _wt_switch_last
  ;;
"add")
  _wt_add "$@"
  ;;
"remove")
  _wt_remove "$@"
  ;;
"list")
  _wt_list
  ;;
-h | --help)
  printf "Usage: wt [subcommand] [arguments]\n\n"
  printf "Subcommands:\n"
  printf "  (none)      Interactively switch worktrees.\n"
  printf "  -           Switch to the last worktree.\n"
  printf "  add <br>    Create or switch to a worktree for a branch.\n"
  printf "  list        List all worktrees.\n"
  printf "  remove <br>  Remove a worktree (not implemented).\n\n"
  printf "Shortcut:\n"
  printf "  wt <name>   Shortcut for 'wt add <name>'.\n"
  exit 2
  ;;
*)
  # Default behavior: treat unknown arg as a shortcut for 'add'
  printf "Running shortcut: wt add %s\n" "$subcommand" >&2
  _wt_add "$subcommand"
  ;;
esac

# Special exit code 2 means the command succeeded but produced no path to cd into.
if [ $? -eq 2 ]; then
  exit 1 # Suppress 'cd' in the wrapper
fi
