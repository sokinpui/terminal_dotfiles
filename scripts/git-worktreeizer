#!/bin/sh
#
# Git Worktree Manager (Extendable Dispatcher Model)

# --- Handler: Switch Interactively ---
_wt_switch() {
  if ! command -v fzf >/dev/null 2>&1; then
    printf "Error: 'fzf' is required for interactive switching.\n" >&2
    exit 1
  fi
  worktree_list=$(git -C "$GIT_ROOT" worktree list)
  if [ -z "$worktree_list" ]; then
    printf "No git worktrees found to switch to.\n" >&2
    exit 1
  fi
  selected_path=$(printf "%s" "$worktree_list" | fzf --height 40% --reverse | awk '{print $1}')
  [ -n "$selected_path" ] && printf "%s" "$selected_path" || exit 1
}

# --- Handler: Switch to Last Worktree ---
_wt_switch_last() {
  LAST_WT_FILE="${HOME}/.wt_last"
  if [ -r "$LAST_WT_FILE" ]; then
    cat "$LAST_WT_FILE"
  else
    printf "Error: No last worktree recorded.\n" >&2
    exit 1
  fi
}

# --- Handler: Add a New Worktree ---
_wt_add() {
  branch_name="$1"
  if [ -z "$branch_name" ]; then
    printf "Error: 'add' command requires a branch name.\nUsage: wt add <branch>\n" >&2
    exit 1
  fi
  if ! git check-ref-format --branch "$branch_name" >/dev/null 2>&1; then
    printf "Error: Invalid branch name: '%s'.\n" "$branch_name" >&2
    exit 1
  fi

  # Parse the branch name to create a valid worktree directory name.
  # Converts any '/' and '-' to '_'.
  worktree_name=$(printf "%s" "$branch_name" | sed 's/[/-]/_/g')
  worktree_path="$GIT_ROOT.wt/$worktree_name"

  if [ -d "$worktree_path" ]; then
    printf "Worktree for branch '%s' already exists at '%s'. Switching.\n" "$branch_name" "$worktree_path" >&2
    printf "%s" "$worktree_path"
    return
  fi

  mkdir -p "$(dirname "$worktree_path")"
  printf "Creating worktree for branch '%s' at '%s'...\n" "$branch_name" "$worktree_path" >&2
  # Check if the branch already exists
  if git rev-parse --verify --quiet "$branch_name" >/dev/null 2>&1; then
    # If branch exists, create worktree from it
    git worktree add "$worktree_path" "$branch_name" >&2
  else
    # If branch doesn't exist, create it with the worktree
    git worktree add -b "$branch_name" "$worktree_path" >&2
  fi

  if [ $? -ne 0 ]; then
    printf "Error: 'git worktree add' failed.\n" >&2
    exit 1
  fi
  printf "%s" "$worktree_path"
}

# --- Handler: Remove a Worktree (Example of extendability) ---
_wt_remove() {
  printf "Error: 'remove' command not yet implemented.\n" >&2
  exit 1
}

# --- Handler: List Worktrees (Example of extendability) ---
_wt_list() {
  git -C "$GIT_ROOT" worktree list
  # This command doesn't output a path, so we exit 2 to prevent 'cd'.
  exit 2
}

# --- Main Dispatcher ---
# Pre-flight check for git repository
GIT_ROOT=$(git worktree list --porcelain | grep "^worktree " | awk '{print $2}' | head -1)
if [ -z "$GIT_ROOT" ]; then
  printf "Error: Not a git repository.\n" >&2
  exit 1
fi

subcommand="$1"
shift_count=1

case "$subcommand" in
"" | "switch")
  _wt_switch
  ;;
"-")
  _wt_switch_last
  ;;
"add")
  _wt_add "$@"
  ;;
"remove")
  _wt_remove "$@"
  ;;
"list")
  _wt_list
  ;;
-h | --help)
  printf "Usage: wt [subcommand] [arguments]\n\n"
  printf "Subcommands:\n"
  printf "  (none)      Interactively switch worktrees.\n"
  printf "  -           Switch to the last worktree.\n"
  printf "  add <br>    Create or switch to a worktree for a branch.\n"
  printf "  list        List all worktrees.\n"
  printf "  remove <br>  Remove a worktree (not implemented).\n\n"
  printf "Shortcut:\n"
  printf "  wt <name>   Shortcut for 'wt add <name>'.\n"
  exit 2
  ;;
*)
  # Default behavior: treat unknown arg as a shortcut for 'add'
  printf "Running shortcut: wt add %s\n" "$subcommand" >&2
  _wt_add "$subcommand"
  ;;
esac

# The final exit code of the script will be the exit code of the
# command that was run in the 'case' statement. We no longer need
# the faulty logic that converted exit code 2 to 1.
