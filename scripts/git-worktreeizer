#!/bin/sh
#
# Git Worktree Manager (Extendable Dispatcher Model)

# --- Handler: Switch Interactively ---
_wt_switch() {
  if ! command -v fzf >/dev/null 2>&1; then
    printf "Error: 'fzf' is required for interactive switching.\n" >&2
    exit 1
  fi
  worktree_list=$(git -C "$GIT_ROOT" worktree list)
  if [ -z "$worktree_list" ]; then
    printf "No git worktrees found to switch to.\n" >&2
    exit 1
  fi
  selected_path=$(printf "%s" "$worktree_list" | fzf --height 40% --reverse | awk '{print $1}')
  [ -n "$selected_path" ] && printf "%s" "$selected_path" || exit 1
}

# --- Handler: Switch to Last Worktree ---
_wt_switch_last() {
  LAST_WT_FILE="${HOME}/.wt_last"
  if [ -r "$LAST_WT_FILE" ]; then
    cat "$LAST_WT_FILE"
  else
    printf "Error: No last worktree recorded.\n" >&2
    exit 1
  fi
}

# --- Handler: Add a New Worktree ---
_wt_add() {
  branch_name="$1"
  if [ -z "$branch_name" ]; then
    printf "Error: 'add' command requires a branch name.\nUsage: wt add <branch>\n" >&2
    exit 1
  fi
  if ! git check-ref-format --branch "$branch_name" >/dev/null 2>&1; then
    printf "Error: Invalid branch name: '%s'.\n" "$branch_name" >&2
    exit 1
  fi

  worktree_name=$(printf "%s" "$branch_name" | sed 's/[/-]/_/g')
  worktree_path="$GIT_ROOT.wt/$worktree_name"

  if [ -d "$worktree_path" ]; then
    printf "Worktree for branch '%s' already exists. Switching.\n" "$branch_name" >&2
    printf "%s" "$worktree_path"
    return 0
  fi

  mkdir -p "$(dirname "$worktree_path")"
  printf "Creating worktree for branch '%s'...\n" "$branch_name" >&2
  if git rev-parse --verify --quiet "$branch_name" >/dev/null 2>&1; then
    git worktree add "$worktree_path" "$branch_name" >&2
  else
    git worktree add -b "$branch_name" "$worktree_path" >&2
  fi

  if [ $? -ne 0 ]; then
    printf "Error: 'git worktree add' failed.\n" >&2
    rm -rf "$worktree_path"
    exit 1
  fi
  printf "%s" "$worktree_path"
  exit 0
}

# --- Handler: Remove a Worktree ---
_wt_remove() {
  if [ -z "$1" ]; then
    printf "Error: 'remove' command requires a branch/worktree name.\nUsage: wt remove [--force] <name>\n" >&2
    exit 1
  fi

  # Capture the output of the git command to decide what to tell the user.
  # We pass all arguments (e.g., --force) to the underlying command.
  output=$(git worktree remove "$@" 2>&1)
  local exit_code=$?

  if [ $exit_code -eq 0 ]; then
    # Success. We print our own message to stdout, which the wrapper will display.
    printf "Worktree for '%s' removed successfully." "$*"
    exit 2 # Informational success
  else
    # Failure. Print the error from git to stderr and fail.
    printf "Error: Failed to remove worktree.\n" >&2
    printf "git said: %s\n" "$output" >&2
    exit 1 # Failure
  fi
}

# --- Handler: List Worktrees ---
_wt_list() {
  git -C "$GIT_ROOT" worktree list
  exit 2
}

# --- Main Dispatcher ---
# Pre-flight check for git repository
GIT_ROOT=$(git worktree list --porcelain | grep "^worktree " | awk '{print $2}' | head -1)
if [ -z "$GIT_ROOT" ]; then
  printf "Error: Not a git repository.\n" >&2
  exit 1
fi

subcommand="$1"
shift_count=1

case "$subcommand" in
"" | "switch")
  _wt_switch
  ;;
"-")
  _wt_switch_last
  ;;
"add")
  _wt_add "$@"
  ;;
"remove")
  _wt_remove "$@"
  ;;
"list")
  _wt_list
  ;;
-h | --help)
  printf "Usage: wt [subcommand] [arguments]\n\n"
  printf "Subcommands:\n"
  printf "  (none)      Interactively switch worktrees.\n"
  printf "  -           Switch to the last worktree.\n"
  printf "  add <br>    Create or switch to a worktree for a branch.\n"
  printf "  list        List all worktrees.\n"
  printf "  remove <br>  Remove a worktree.\n\n"
  printf "Shortcut:\n"
  printf "  wt <name>   Shortcut for 'wt add <name>'.\n"
  exit 2
  ;;
*)
  # Default behavior: treat unknown arg as a shortcut for 'add'
  printf "Running shortcut: wt add %s\n" "$subcommand" >&2
  _wt_add "$subcommand"
  ;;
esac
