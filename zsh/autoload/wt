# vi: set filetype=zsh
# Wrapper function for the git-worktreeizer script.

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf "Error: Not a git repository.\n" >&2
    return 1
fi

# Handle 'remove' command directly in the wrapper
if [[ "$1" == "rm" ]]; then
    shift # Consume 'rm'
    local force=0
    local branch_to_remove=""

    while (( $# > 0 )); do
        case "$1" in
            -f|--force)
                force=1
                shift
                ;;
            -*)
                printf "Error: Unknown option '%s' for rm command.\n" "$1" >&2
                return 1
                ;;
            *)
                if [[ -n "$branch_to_remove" ]]; then
                    printf "Error: Only one branch can be removed at a time.\n" >&2
                    return 1
                fi
                branch_to_remove="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$branch_to_remove" ]]; then
        printf "Error: Branch name not specified.\n" >&2
        printf "Usage: wt rm [-f|--force] <branch>\n" >&2
        return 1
    fi

    # Prevent removing main/master/develop for safety
    if [[ "$branch_to_remove" == "main" || "$branch_to_remove" == "master" || "$branch_to_remove" == "develop" ]]; then
        printf "Error: Refusing to remove protected branch '%s' for safety.\n" "$branch_to_remove" >&2
        return 1
    fi

    # Prevent removing current branch
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ "$current_branch" == "$branch_to_remove" ]]; then
        printf "Error: Cannot remove the current branch '%s'. Switch to another branch first.\n" "$branch_to_remove" >&2
        return 1
    fi

    # Find worktree path for the branch
    local worktree_path
    worktree_path=$(git worktree list --porcelain | awk -v b="refs/heads/${branch_to_remove}" '
        /^worktree / {path=$2}
        /^branch / && $2==b {print path; exit}')

    if [[ -n "$worktree_path" ]]; then
        printf "Removing worktree at %s...\n" "$worktree_path"
        local remove_args=()
        (( force )) && remove_args+=(--force)

        if ! git worktree remove "${remove_args[@]}" "$worktree_path"; then
            printf "Error: Failed to remove worktree for branch '%s'.\n" "$branch_to_remove" >&2
            printf "It might have uncommitted changes. Use -f to force removal.\n" >&2
            return 1
        fi
    else
        if ! git rev-parse --verify "$branch_to_remove" >/dev/null 2>&1; then
            printf "Error: Branch '%s' does not exist.\n" "$branch_to_remove" >&2
            return 1
        fi
        printf "No worktree found for branch '%s'. Will only attempt to delete the branch.\n" "$branch_to_remove"
    fi

    # Delete branch
    printf "Deleting branch '%s'...\n" "$branch_to_remove"
    local delete_args=(-d)
    (( force )) && delete_args=(-D)

    if ! git branch "${delete_args[@]}" "$branch_to_remove"; then
        printf "Error: Failed to delete branch '%s'.\n" "$branch_to_remove" >&2
        printf "It might not be fully merged. Use -f to force deletion.\n" >&2
        return 1
    fi

    printf "Successfully removed worktree and/or branch '%s'.\n" "$branch_to_remove"
    return 0
fi

local script_output
local exit_code
local last_wt_file="${HOME}/.wt_last"

# Run the dispatcher script, capturing its stdout and exit code.
# Stderr is passed through, so error messages from the script appear immediately.
script_output=$(git-worktreeizer "$@")
exit_code=$?

# Act based on the exit code from the script.
case $exit_code in
  0)
    # Exit code 0: Success, and a path was returned to cd into.
    if [ -n "$script_output" ] && [ -d "$script_output" ]; then
      # Save the current directory path before changing to the new one.
      printf "%s" "$PWD" > "$last_wt_file"
      cd "$script_output" || return 1
    elif [ -n "$script_output" ]; then
      # This case handles when a path was returned but it's not a directory.
      printf "Error: Target path '%s' is not a directory.\n" "$script_output" >&2
      return 1
    fi
    ;;
  2)
    # Exit code 2: Success, this was an informational command (e.g., list, remove).
    # The command's output was captured in script_output, so we print it.
    # We add a newline for commands that might not output one.
    printf "%s\n" "$script_output"
    ;;
  1 | *)
    # Exit code 1 or any other: An error occurred.
    # The script already printed an error message to stderr.
    # We just pass the error code along.
    return $exit_code
    ;;
esac
