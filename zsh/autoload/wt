# vi: set filetype=zsh
# Wrapper function for the git-worktreeizer script.

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    printf "Error: Not a git repository.\n" >&2
    return 1
fi

if [[ "$1" == "-" ]]; then
    local main_worktree_root
    main_worktree_root=$(git worktree list | head -n 1 | awk '{print $1}')
    if [[ -z "$main_worktree_root" ]]; then
        printf "Error: Not a git repository.\n" >&2
        return 1
    fi

    local last_wt_file="${main_worktree_root}/.wt_last"
    if [[ ! -f "$last_wt_file" ]]; then
        printf "Error: No last worktree recorded for this repository.\n" >&2
        return 1
    fi

    local target_dir
    target_dir=$(<"$last_wt_file")
    local current_dir="$PWD"

    if [[ -d "$target_dir" ]]; then
        printf "%s" "$current_dir" > "$last_wt_file"
        cd "$target_dir" || return 1
    else
        printf "Error: Last worktree path '%s' is no longer valid.\n" "$target_dir" >&2
        return 1
    fi
    return 0
elif [[ "$1" == "rm" ]]; then
    shift # Consume 'rm'
    local force=0
    local branch_to_remove=""

    while (( $# > 0 )); do
        case "$1" in
            -f|--force)
                force=1
                shift
                ;;
            -*)
                printf "Error: Unknown option '%s' for rm command.\n" "$1" >&2
                return 1
                ;;
            *)
                if [[ -n "$branch_to_remove" ]]; then
                    printf "Error: Only one branch can be removed at a time.\n" >&2
                    return 1
                fi
                branch_to_remove="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$branch_to_remove" ]]; then
        printf "Error: Branch name not specified.\n" >&2
        printf "Usage: wt rm [-f|--force] <branch>\n" >&2
        return 1
    fi

    # Prevent removing main/master/develop for safety
    if [[ "$branch_to_remove" == "main" || "$branch_to_remove" == "master" || "$branch_to_remove" == "develop" ]]; then
        printf "Error: Refusing to remove protected branch '%s' for safety.\n" "$branch_to_remove" >&2
        return 1
    fi

    # Prevent removing current branch
    local current_branch
    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ "$current_branch" == "$branch_to_remove" ]]; then
        printf "Error: Cannot remove the current branch '%s'. Switch to another branch first.\n" "$branch_to_remove" >&2
        return 1
    fi

    # Find worktree path for the branch
    local worktree_path
    worktree_path=$(git worktree list --porcelain | awk -v b="refs/heads/${branch_to_remove}" '
        /^worktree / {path=$2}
        /^branch / && $2==b {print path; exit}')

    if [[ -n "$worktree_path" ]]; then
        printf "Removing worktree at %s...\n" "$worktree_path"
        local remove_args=()
        (( force )) && remove_args+=(--force)

        if ! git worktree remove "${remove_args[@]}" "$worktree_path"; then
            printf "Error: Failed to remove worktree for branch '%s'.\n" "$branch_to_remove" >&2
            printf "It might have uncommitted changes. Use -f to force removal.\n" >&2
            return 1
        fi
    else
        if ! git rev-parse --verify "$branch_to_remove" >/dev/null 2>&1; then
            printf "Error: Branch '%s' does not exist.\n" "$branch_to_remove" >&2
            return 1
        fi
        printf "No worktree found for branch '%s'. Will only attempt to delete the branch.\n" "$branch_to_remove"
    fi

    # Delete branch
    printf "Deleting branch '%s'...\n" "$branch_to_remove"
    local delete_args=(-d)
    (( force )) && delete_args=(-D)

    if ! git branch "${delete_args[@]}" "$branch_to_remove"; then
        printf "Error: Failed to delete branch '%s'.\n" "$branch_to_remove" >&2
        printf "It might not be fully merged. Use -f to force deletion.\n" >&2
        return 1
    fi

    printf "Successfully removed worktree and/or branch '%s'.\n" "$branch_to_remove"
    return 0
fi

local script_output
local exit_code
local pre_cmd_pwd="$PWD" # Record where we started

# Run the dispatcher script, capturing its stdout and exit code.
# Stderr is passed through, so error messages from the script appear immediately.
script_output=$(git-worktreeizer "$@")
exit_code=$?

# Act based on the exit code from the script.
case $exit_code in
  0)
    # Exit code 0: Success, and a path was returned to cd into.
    if [ -n "$script_output" ] && [ -d "$script_output" ]; then
      # Convert the worktree path in .git/worktrees to be relative to make the repository portable.
      local relpath() {
          local target=$1 base=$2
          local -a t_arr b_arr
          t_arr=(${(s:/:)target}); [[ -z $t_arr[1] ]] && t_arr=(${t_arr[@]:1})
          b_arr=(${(s:/:)base}); [[ -z $b_arr[1] ]] && b_arr=(${b_arr[@]:1})

          local common_len=0
          while (( common_len < ${#t_arr} && common_len < ${#b_arr} && t_arr[common_len+1] == b_arr[common_len+1] )); do
              (( common_len++ ))
          done

          local -a up_parts
          for ((i=0; i < ${#b_arr} - common_len; i++)); do up_parts+=(".."); done
          local down_parts=(${t_arr[@]:$common_len})

          local result
          if (( ${#up_parts} > 0 )); then
              result=${(j:/:)up_parts}
              if (( ${#down_parts} > 0 )); then result="$result/${(j:/:)down_parts}"; fi
          elif (( ${#down_parts} > 0 )); then
              result=${(j:/:)down_parts}
          else
              result="."
          fi
          printf "%s" "$result"
      }

      local new_worktree_path=$(cd "$script_output" >/dev/null && pwd)
      local gitdir_path=$(git worktree list --porcelain | awk -v path="$new_worktree_path" '
          BEGIN { found=0 }
          /^worktree / { if ($2 == path) found=1; else found=0; }
          found && /^gitdir / { print $2; exit }')

      if [[ -n "$gitdir_path" && -f "${gitdir_path}/gitdir" ]]; then
          printf "%s" "$(relpath "$new_worktree_path" "$gitdir_path")" > "${gitdir_path}/gitdir"
      fi

      cd "$script_output" || return 1
    elif [ -n "$script_output" ]; then
      # This case handles when a path was returned but it's not a directory.
      printf "Error: Target path '%s' is not a directory.\n" "$script_output" >&2
      return 1
    fi
    ;;
  2)
    # Exit code 2: Success, this was an informational command (e.g., list, remove).
    # The command's output was captured in script_output, so we print it.
    # We add a newline for commands that might not output one.
    printf "%s\n" "$script_output"
    ;;
  1 | *)
    # An error occurred. The script already printed a message to stderr.
    return $exit_code
    ;;
esac

# Unified State Saving: If the directory changed for any reason, a switch occurred.
if [[ "$PWD" != "$pre_cmd_pwd" ]]; then
    # Find the main worktree root, which is the canonical location for the state file.
    local main_worktree_root
    main_worktree_root=$(git worktree list | head -n 1 | awk '{print $1}')
    if [[ -n "$main_worktree_root" ]]; then
        printf "%s" "$pre_cmd_pwd" > "${main_worktree_root}/.wt_last"
    fi
fi
